/**
 * https://leetcode.cn/problems/permutations/description/
  给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

  示例 1：
  输入：nums = [1,2,3]
  输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
  示例 2：

  输入：nums = [0,1]
  输出：[[0,1],[1,0]]
  示例 3：

  输入：nums = [1]
  输出：[[1]]
*/


/**
 * 解题思路：
 * 1. 基本概念  
 *    1.1 全排列意味着使用数组中的所有数字，每种排列都不重复
 *    1.2 对于n个数字，总共有n!种排列方式
 *    1.3 需要保证每个数字恰好使用一次
 * 2. 回溯法 核心思想
 *    2.1 通过递归逐步构建排列
 *    2.2 使用一个visited标记数组记录哪些数字已经被使用
 *    2.3 当当前排列长度等于输入数组长度时，记录结果
 *    2.4 通过回溯撤销选择，尝试其他可能性
 * 3. 实现步骤
 *    3.1 定义结果集存储所有排列
 *    3.2 定义临时路径存储当前构建的排列
 *    3.3 定义visited数组标记使用过的数字
 *    3.4 递归生成所有可能性
 */
function permute(nums) {
  if (nums.length === 0) return [[]];
  // 定义最终得结果
  const result = []
  // 定义访问过得元素数组
  const visited = new Array(nums.length).fill(false)
  // 定义递归函数进行处理
  const backTrack = (curPerm) => {
    // 如果临时数组得长度 等于 数据源得长度，则表明已经完成一个排列，推入总结果
    if(curPerm.length === nums.length) {
      result.push([...curPerm])
      return
    }
    // 如果没有满足，处理当前得排列
    for(let i = 0; i < nums.length; i++) {
      if(!visited[i]) {
        visited[i] = true     // 标记当前元素以访问
        curPerm.push(nums[i]) // 将当前元素 推入 数组
        backTrack(curPerm)    // 递归进入 获取其他元素
        curPerm.pop()         // 弹出一个元素
        visited[i] = false    // 将当前弹出得元素标记为false
      }
    }
  }
  backTrack([])
  return result
}

/**
  [1, 2, 3]

  循环 1 个 进入递归        最外层  for 循环 i === 1
  -> [1]
  循环两个进入递归          最外层  for 循环 i === 2
  -> [1, 2]
  循环三个进入递归          最外层  for 循环 i === 3
  -> [1, 2, 3] 推入数组

  不满组循环条件         第三层 递归终止  剩余两层
  -> [1, 2]       
  -> [1]
  -> [1, 3]
  -> [1, 3, 2]    推入数组
  -> [1, 3]
  -> [1] 
  -> [2]
  -> [2, 1]
  -> [2, 1, 3] 推入数组
  -> [2, 1]
  -> [2]
  -> [2, 3]
  -> [2, 3, 1] 推入数组
  -> [2,3]
  -> [2]
  -> [3]
  -> [3, 1]
  -> [3, 1, 2]推入数组
  -> [3, 1]
  -> [3]
  -> [3, 2]
  -> [3, 2, 1]  推入数组

*/
console.log(permute([1, 2, 3]))

// 时间复杂度： 每次循环一个 都是 n！ n次总循环  O(N*n!)
// 空间复杂度： 递归深度 O(N) 返回值 O(n!) visited O(n)  curPerm O(n) 总得O(n)



